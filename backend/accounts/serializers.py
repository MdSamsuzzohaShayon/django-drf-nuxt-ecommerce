import jwt
import os 
import logging
from django.contrib.auth import get_user_model
from rest_framework import serializers
from django.contrib.auth.password_validation import validate_password
from django.db import IntegrityError
from .models import User
from drfecom.keys import TokenTypes
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer

"""
serializing Objects - > https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects
Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types.
The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields.
Field-level validation -> https://www.django-rest-framework.org/api-guide/serializers/#field-level-validation
Object-level validation -> https://www.django-rest-framework.org/api-guide/serializers/#object-level-validation
The following example demonstrates how you might handle creating a user with a nested profile object.
.create() and .update() - Override either or both of these to support saving instances.
"""
class SignupSerializer(serializers.Serializer):
    first_name = serializers.CharField()
    last_name = serializers.CharField()
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True) # need to validate by external validators , validators=[validate_password]
    confirm_password = serializers.CharField(write_only=True)

    # To do any other validation that requires access to multiple fields, add a method called .validate()
    def validate(self, data):
        # print("validate", data)
        password = data.get('password')
        confirm_password = data.pop('confirm_password')
        if password != confirm_password:
            raise serializers.ValidationError("Password did not match!")
        return data
    
    def create(self, validated_data):
        try:
            user = get_user_model().objects.create_user(**validated_data)
            user.save()
            return user
        except IntegrityError as e:
            raise serializers.ValidationError({'email': ['This email address is already taken.']}) 
        
    def update(self, instance, validated_data):
        """
        Update and return an existing `Snippet` instance, given the validated data.
        """
        instance.email = validated_data.get('email', instance.email)
        instance.set_password(validated_data.get('password'))
        instance.save()
        return instance
    
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'email', 'first_name', 'last_name', 'is_admin', 'is_validated', 'is_admin', 'is_staff', 'is_active']    


class PasswordForgotSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate(self, user_data):
        if get_user_model().objects.filter(email=user_data.get('email')).exists():
            user_data['user'] = User.objects.get(email=user_data.get('email'))
        else:
            raise serializers.ValidationError("This email address is not associated with any user account.")
        return user_data
    

class PasswordResetSerializer(serializers.Serializer):
    password = serializers.CharField(write_only=True)
    confirm_password = serializers.CharField(write_only=True) # use validators here

    def validate(self, data):
        decoded_token = None
        try:
            decoded_token = jwt.decode(self.context['token'], os.getenv('JSON_TOKEN_SECRET'), algorithms=["HS256"])
            if decoded_token['type'] != TokenTypes.RESET_PASSWORD.value:
                raise serializers.ValidationError("Invalid token")
        except jwt.exceptions.ExpiredSignatureError:
            raise serializers.ValidationError("The token had been expired")
        except Exception as e:
            logging.error(e)

        if data.get('password') != data.get('confirm_password'):
            raise serializers.ValidationError("Passwords do not match.")
        data['email'] = decoded_token["email"]
        return data
    
    def create(self, validated_data):
        user = get_user_model().objects.get(email=validated_data.get('email'))
        user.set_password(validated_data.get('password'))
        user.save()

        return user

    
"""
customize the claims contained in web tokens which are generated by the TokenObtainPairView and TokenObtainSlidingView views, create a subclass for the desired view as well as a subclass for its corresponding serializer.
https://django-rest-framework-simplejwt.readthedocs.io/en/latest/customizing_token_claims.html
"""
class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):

    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)

        token['username'] = user.username
        return token

